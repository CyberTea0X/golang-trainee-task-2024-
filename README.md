# golang-trainee-task-2024-

## Чеклист выполненных пунктов задания

 - Основное задание выполнено
 - Описать конфигурацию линтера: стандартная конфигурация [линтера](https://github.com/golangci/golangci-lint)
 - Реализовать интеграционное или E2E-тестирование для остальных сценариев

## Стек

 - Язык программирования: Go(golang)
 - База данных: PostgreSQL
 - Деплой зависимостей и самого сервиса: Docker или Docker Compose

## Деплой зависимостей и самого сервиса

Для любого из вариантов запуска вам понадобится [установленный golang](https://go.dev/doc/install).
Впоследствии можно будет его удалить и пользоваться только собранным контейнером или
двоичным файлом. Также можно загрузить docker image на dockerhub для развёртывания
без лишних зависимостей.


 > Примечание: запуск сервиса протестирован только на linux. Для windows процесс
 скорее всего будет отличаться (особенно через docker compose) и могут возникнуть определённые
 трудности. Рекомендуется производить сборку и запуск проекта на linux.
 Например, можно использовать виртуальную машину ubuntu LTS.

 > Сервис сам создаёт все необходимые таблицы в базе данных.

Клонируйте этот репозиторий и перейдите в папку репозитория:

```bash
git clone https://github.com/CyberTea0X/golang-trainee-task-2024-.git
cd golang-trainee-task-2024-
```

Далее предполагается что вы изначально в папке репозитория.

### Через docker

Убедитесь что у вас установлен и настроен docker для вашей операционной системы.

Также вам понадобится утилита make для сборки, либо можете просто скопировать
команду из [Makefile](./Makefile) (секция build).
Утилита make обычно уже установлена на большинстве диструбивов linux, включая ubuntu.

Также у вас должен быть доступ к базе данных postgres (возможность создавать таблицы и
т.п. в указанной базе данных).
Либо вы можете запустить свою postgres базу данных командой `make start-db`.

Скомпилируйте бинарник так, чтобы его можно было запустить в alpine docker контейнере:

```bash
make build
```

Если вы сделали всё так, как указано, в папке появится исполняемый файл с названием
gobanners. Если название вашего исполняемого файла отличается лучше его переименовать,
либо придётся менять Dockerfile.

Укажите все необходимые переменные среды в файле .env (смотрите файл [env_example](./env_example).

Теперь вы можете запустить docker контейнер. Например, так:

 > При использовании этой команды сервис должен быть доступен локально на порту 8080
 > Это можно изменить при помощи переменной среды `PORT`, переданной в докер контейнер

```bash
docker run \
    -v ./.env:/gobanners/.env \
    --network="host" \
    --rm cybertea0x/gobanners
```

### Через docker compose

Убедитесь что у вас установлены и настроены docker, docker_compose.
Также вам понадобится утилита make для сборки, либо можете просто скопировать
команду из [Makefile](./Makefile) (секция build).
Утилита make обычно уже установлена на большинстве диструбивов linux, включая ubuntu.

Скомпилируйте бинарник так, чтобы его можно было запустить в alpine docker контейнере:

```bash
make build
```

Если вы сделали всё так, как указано, в папке появится исполняемый файл с названием
gobanners. Если название вашего исполняемого файла отличается лучше его переименовать,
либо придётся менять Dockerfile.

Укажите все необходимые переменные среды в файле .env (смотрите файл [env_example](./env_example).
Также можно указывать их вручную без файла, но это довольно-таки утомительный процесс.

Далее просто пропишите:

```bash
docker compose up
```

Эта команда запустит контейнер базы данных и контейнер сервиса. Сервис автоматически
настроит базу данных и подключится к ней.

По умолчанию сервис займёт порт 8080.
Чтобы это изменить, необходимо указать переменную окружения PORT перед запуском docker compose.
База данных займёт порт 5432, это можно легко изменить в compose.yaml (не забудьте также поменять порт в .env).

Пример:

```bash
PORT=25565 docker compose up
```

### Сборка из исходников и запуск

Сперва убедитесь что у вас запущена база данных postgres в докере, локально,
или на удалённом сервере и у вас есть к ней доступ (вы можете зайти в неё с паролем,
создать таблицу и т.п.).


Укажите все необходимые переменные среды в файле .env (смотрите файл [env_example](./env_example).

Способ 1: 

```bash
go run .
```

Способ 2:

```bash
go build -o gobanners
```

Запустите сервис:

```bash
./gobanners
```

Двоичный файл вместе с .env можно поместить туда, куда вам нужно, остальное
можно удалить.

## Как работать с сервисом и документация API

Для начала разверните сервис где-нибудь и запишите ip и port, убедитесь, что
у вас есть доступ к этому адресу и порту.

Файл [openapi.html](./docs/openapi.html) можно открыть в браузере. В этом
файле описаны API и примеры запросов.

Файл [openapi.yaml](./docs/openapi.yaml) содержит документацию api в формате
openapi. Если вы не знаете, что это такое, лучше откройте его html версию.

Также можете импортировать файл [openapi.yaml](./docs/openapi.yaml) как API в Postman, после чего
создать на его основе коллекцию. После указания переменной адреса сервиса в коллекции,
вы можете выполнять запросы к сервису. Для большинства переменных postman установит заглушки
вида `\<integer\>`, поэтому их придётся заменить другими данными.

### Curl

Также вы можете обращаться к сервису через curl. 

Например, так вы можете создать баннер:
Данный запрос сработает, если сервис запущен локально на порту 8080, иначе,
вам придётся его модифицировать:

```bash
curl --location 'localhost:8080/banner' \
--header 'token: admin_token' \
--header 'Content-Type: application/json' \
--header 'Accept: application/json' \
--data '{
  "tag_ids": [1,2],
  "feature_id": 1,
  "content": "{\"title\": \"тестерс гонна тест\"}",
  "is_active": true
}'
```

Пример ответа для запроса выше: 

```json
{
    "banner_id": 1
}
```

Так вы можете получить содержимое баннера:

```bash
curl --location 'localhost:8080/user_banner?tag_id=1&feature_id=1&use_last_revision=false' \
--header 'token: user_token' \
--header 'Accept: application/json'
```

Пример ответа для запроса выше:

```json
{
    "title": "тестерс гонна тест"
}
```

Так вы можете обновить баннер:

```bash
curl --location --request PATCH 'localhost:8080/banner/1' \
--header 'token: admin_token' \
--header 'Content-Type: application/json' \
--header 'Accept: application/json' \
--data '{
  "tag_ids": [
    1
  ]
}'
```

Пример ответа: HTTP 200

Так вы можете получить баннеры с фильтрацией по фиче и/или тегу:

```bash
curl --location 'localhost:8080/banner?feature_id=1&tag_id=1&limit=1&offset=0' \
--header 'token: admin_token' \
--header 'Accept: application/json'
```

Пример ответа:

```json
[
    {
        "Id": 2,
        "tag_ids": [
            1,
            2
        ],
        "feature_id": 1,
        "content": "{}",
        "is_active": true,
        "created_at": "2024-04-14T16:07:31.515188Z",
        "updated_at": "2024-04-14T16:07:31.515188Z"
    },
    {
        "Id": 3,
        "tag_ids": [
            3
        ],
        "feature_id": 1,
        "content": "{\"title\": \"тестерс гонна тест\"}",
        "is_active": true,
        "created_at": "2024-04-14T16:19:30.595649Z",
        "updated_at": "2024-04-14T16:19:30.595649Z"
    }
]
```

Так вы можете удалить баннер:

```bash
curl --location --request DELETE 'localhost:8080/banner/1' \
--header 'token: admin_token' \
--header 'Accept: application/json'
```

Пример ответа: HTTP код 204

## Возникшие вопросы при выполнении задания

В `api.yaml` для GET /banner не был указан вариант ошибки 400, добавил это
